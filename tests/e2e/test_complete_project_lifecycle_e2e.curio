# CurioShelf Complete Project Lifecycle End-to-End Test
# This script tests the complete project workflow including all recent fixes

print("=== CurioShelf Complete Project Lifecycle E2E Test ===")
print("Testing complete project workflow with UI interactions and state transitions")

# Test 1: Initial Application State
print("\n=== Test 1: Initial Application State ===")
print("Checking initial application state...")

# Check if project is loaded (should be false initially)
project_loaded := is_project_loaded()
print("Project loaded initially:", project_loaded)
assert(not project_loaded, "Project should not be loaded initially")

# Check UI state functions
can_create := can_create_project()
can_open := can_open_project()
can_save := can_save_project()
can_close := can_close_project()
can_import := can_import_source()

print("Can create project:", can_create)
print("Can open project:", can_open)
print("Can save project:", can_save)
print("Can close project:", can_close)
print("Can import source:", can_import)

# These should be true initially
assert(can_create, "Should be able to create project initially")
assert(can_open, "Should be able to open project initially")
assert(not can_save, "Should not be able to save project initially")
assert(not can_close, "Should not be able to close project initially")
assert(not can_import, "Should not be able to import source initially")

# Test 2: Project Creation via UI
print("\n=== Test 2: Project Creation via UI ===")
print("Triggering New Project menu...")

# Trigger the New Project menu item
trigger_menu("Project", "New Project")
print("New Project menu triggered")

# Wait a moment for the dialog to appear and be auto-responded
print("Waiting for project creation to complete...")

# Check if project was created
project_loaded_after_create := is_project_loaded()
print("Project loaded after creation:", project_loaded_after_create)
assert(project_loaded_after_create, "Project should be loaded after creation")

# Get project information
project_info := get_project_info()
print("Project info:", project_info)
assert(project_info.get("name", "") != "", "Project should have a name")
assert(project_info.get("path", "") != "", "Project should have a path")

# Check UI state after project creation
can_save_after_create := can_save_project()
can_close_after_create := can_close_project()
can_create_after_create := can_create_project()
can_open_after_create := can_open_project()
can_import_after_create := can_import_source()

print("Can save after creation:", can_save_after_create)
print("Can close after creation:", can_close_after_create)
print("Can create after creation:", can_create_after_create)
print("Can open after creation:", can_open_after_create)
print("Can import after creation:", can_import_after_create)

assert(can_save_after_create, "Should be able to save project after creation")
assert(can_close_after_create, "Should be able to close project after creation")
assert(not can_create_after_create, "Should not be able to create project when one is loaded")
assert(not can_open_after_create, "Should not be able to open project when one is loaded")
assert(can_import_after_create, "Should be able to import source after project creation")

# Test 3: Import Source via UI
print("\n=== Test 3: Import Source via UI ===")
print("Testing import source functionality...")

# Get initial asset counts
initial_counts := get_asset_counts()
print("Initial asset counts:", initial_counts)
assert(initial_counts.get("sources", 0) == 0, "Should start with 0 sources")

# Trigger the Import Source menu item
print("Triggering Import Source menu...")
trigger_menu("Sources", "Import Source")
print("Import Source menu triggered")

# Wait for file dialog and auto-response
print("Waiting for source import to complete...")

# Check if source was imported
final_counts := get_asset_counts()
print("Final asset counts:", final_counts)

# Note: The auto-responder should handle the file dialog, but we can't guarantee
# a file will be selected in the test environment, so we'll just verify the
# menu was triggered and the system didn't hang

# Test 4: Save Project
print("\n=== Test 4: Save Project ===")
print("Saving project...")

save_result := save_project()
print("Save result:", save_result)
assert(save_result, "Project save should succeed")

# Test 5: Close Project
print("\n=== Test 5: Close Project ===")
print("Closing project...")

close_result := close_project()
print("Close result:", close_result)
assert(close_result, "Project close should succeed")

# Check state after closing
project_loaded_after_close := is_project_loaded()
print("Project loaded after close:", project_loaded_after_close)
assert(not project_loaded_after_close, "Project should not be loaded after closing")

# Check UI state after closing (this tests our fix)
can_create_after_close := can_create_project()
can_open_after_close := can_open_project()
can_save_after_close := can_save_project()
can_close_after_close := can_close_project()
can_import_after_close := can_import_source()

print("Can create after close:", can_create_after_close)
print("Can open after close:", can_open_after_close)
print("Can save after close:", can_save_after_close)
print("Can close after close:", can_close_after_close)
print("Can import after close:", can_import_after_close)

assert(can_create_after_close, "Should be able to create project after closing")
assert(can_open_after_close, "Should be able to open project after closing")
assert(not can_save_after_close, "Should not be able to save project after closing")
assert(not can_close_after_close, "Should not be able to close project after closing")
assert(not can_import_after_close, "Should not be able to import source after closing")

# Test 6: Project Opening via UI (tests directory browsing fix)
print("\n=== Test 6: Project Opening via UI ===")
print("Triggering Open Project menu...")

# Trigger the Open Project menu item
trigger_menu("Project", "Open Project")
print("Open Project menu triggered")

# Wait for dialog and auto-response
print("Waiting for project opening to complete...")

# Check if project was opened (this might fail if no projects exist)
project_loaded_after_open := is_project_loaded()
print("Project loaded after open:", project_loaded_after_open)

# Initialize variable before if statement
project_info_after_open := ""

if project_loaded_after_open:
    # If a project was opened, get its info
    project_info_after_open := get_project_info()
    print("Project info after open:", project_info_after_open)
    
    # Test UI state after opening
    can_save_after_open := can_save_project()
    can_close_after_open := can_close_project()
    can_create_after_open := can_create_project()
    can_open_after_open := can_open_project()
    can_import_after_open := can_import_source()
    
    print("Can save after open:", can_save_after_open)
    print("Can close after open:", can_close_after_open)
    print("Can create after open:", can_create_after_open)
    print("Can open after open:", can_open_after_open)
    print("Can import after open:", can_import_after_open)
    
    assert(can_save_after_open, "Should be able to save project after opening")
    assert(can_close_after_open, "Should be able to close project after opening")
    assert(not can_create_after_open, "Should not be able to create project when one is loaded")
    assert(not can_open_after_open, "Should not be able to open project when one is loaded")
    assert(can_import_after_open, "Should be able to import source after opening")
    
    # Close it again
    close_result_2 := close_project()
    print("Close result after open:", close_result_2)
    assert(close_result_2, "Should be able to close project after opening")
else:
    print("No project was opened (likely no projects available)")

# Test 7: Multiple Project Lifecycle (Create -> Close -> Create)
print("\n=== Test 7: Multiple Project Lifecycle ===")
print("Testing multiple project create/close cycles...")

# Create first project
print("Creating first project...")
trigger_menu("Project", "New Project")
print("First project creation triggered")

# Wait and check
project_loaded_1 := is_project_loaded()
print("First project loaded:", project_loaded_1)
assert(project_loaded_1, "First project should be loaded")

# Close first project
print("Closing first project...")
close_result_1 := close_project()
print("First project close result:", close_result_1)
assert(close_result_1, "First project should close successfully")

# Verify UI state is reset
can_create_after_close_1 := can_create_project()
can_open_after_close_1 := can_open_project()
print("Can create after first close:", can_create_after_close_1)
print("Can open after first close:", can_open_after_close_1)
assert(can_create_after_close_1, "Should be able to create project after first close")
assert(can_open_after_close_1, "Should be able to open project after first close")

# Create second project
print("Creating second project...")
trigger_menu("Project", "New Project")
print("Second project creation triggered")

# Wait and check
project_loaded_2 := is_project_loaded()
print("Second project loaded:", project_loaded_2)
assert(project_loaded_2, "Second project should be loaded")

# Close second project
print("Closing second project...")
close_result_2 := close_project()
print("Second project close result:", close_result_2)
assert(close_result_2, "Second project should close successfully")

# Test 8: Final State Verification
print("\n=== Test 8: Final State Verification ===")
print("Verifying final application state...")

# Get project status (should be empty)
final_status := get_project_status()
print("Final project status:", final_status)

# Verify no project is loaded
final_project_loaded := is_project_loaded()
print("Final project loaded state:", final_project_loaded)
assert(not final_project_loaded, "No project should be loaded at the end")

# Verify UI state is correct
final_can_create := can_create_project()
final_can_open := can_open_project()
final_can_save := can_save_project()
final_can_close := can_close_project()
final_can_import := can_import_source()

print("Final state - Can create:", final_can_create)
print("Final state - Can open:", final_can_open)
print("Final state - Can save:", final_can_save)
print("Final state - Can close:", final_can_close)
print("Final state - Can import:", final_can_import)

assert(final_can_create, "Should be able to create project at the end")
assert(final_can_open, "Should be able to open project at the end")
assert(not final_can_save, "Should not be able to save project at the end")
assert(not final_can_close, "Should not be able to close project at the end")
assert(not final_can_import, "Should not be able to import source at the end")

print("\n=== Complete Project Lifecycle E2E Test Complete ===")
print("All tests passed successfully!")
print("✅ Project creation works")
print("✅ Project closing works and resets UI state")
print("✅ Project opening works with directory browsing")
print("✅ Import source menu is properly enabled/disabled")
print("✅ Multiple project lifecycle works correctly")
print("✅ UI state transitions are correct throughout")

# Exit gracefully
exit(0)
